{"mappings":"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","sources":["dist/user_scripts/XAudioJS/XAudioServer.js"],"sourcesContent":["//XAudioJS realtime audio output compatibility library\n//Copyright (C) 2010-2015 Grant Galitz\n//Released to Public Domain\nvar XAudioJSscriptsHandle = document.getElementsByTagName(\"script\");\nvar XAudioJSsourceHandle = XAudioJSscriptsHandle[XAudioJSscriptsHandle.length-1].src;\nfunction XAudioServer(channels, sampleRate, minBufferSize, maxBufferSize, underRunCallback, heartbeatCallback, postheartbeatCallback, volume, failureCallback, userEventLatch) {\n\tXAudioJSChannelsAllocated = Math.max(channels, 1);\n\tthis.XAudioJSSampleRate = Math.abs(sampleRate);\n\tXAudioJSMinBufferSize = (minBufferSize >= (XAudioJSSamplesPerCallback * XAudioJSChannelsAllocated) && minBufferSize < maxBufferSize) ? (minBufferSize & (-XAudioJSChannelsAllocated)) : (XAudioJSSamplesPerCallback * XAudioJSChannelsAllocated);\n\tXAudioJSMaxBufferSize = (Math.floor(maxBufferSize) > XAudioJSMinBufferSize + XAudioJSChannelsAllocated) ? (maxBufferSize & (-XAudioJSChannelsAllocated)) : (XAudioJSMinBufferSize * XAudioJSChannelsAllocated);\n\tthis.underRunCallback = (typeof underRunCallback == \"function\") ? underRunCallback : function () {};\n    XAudioJSCallbackAPIEventNotificationCallback = (typeof heartbeatCallback == \"function\") ? heartbeatCallback : null;\n    XAudioJSCallbackAPIEventNotificationCallback2 = (typeof postheartbeatCallback == \"function\") ? postheartbeatCallback : null;\n\tXAudioJSVolume = (volume >= 0 && volume <= 1) ? volume : 1;\n\tthis.failureCallback = (typeof failureCallback == \"function\") ? failureCallback : function () { throw(new Error(\"XAudioJS has encountered a fatal error.\")); };\n\tthis.userEventLatch = (typeof userEventLatch == \"object\") ? userEventLatch : null;\n\tthis.initializeAudio();\n}\nXAudioServer.prototype.MOZWriteAudioNoCallback = function (buffer, upTo) {\n    //Resample before passing to the moz audio api:\n    var bufferLength  = Math.min(buffer.length, upTo);\n    for (var bufferIndex = 0; bufferIndex < bufferLength;) {\n        var sliceLength = Math.min(bufferLength - bufferIndex, XAudioJSMaxBufferSize);\n        for (var sliceIndex = 0; sliceIndex < sliceLength; ++sliceIndex) {\n            XAudioJSAudioContextSampleBuffer[sliceIndex] = buffer[bufferIndex++];\n        }\n        var resampleLength = XAudioJSResampleControl.resampler(sliceIndex);\n        if (resampleLength > 0) {\n            var resampledResult = XAudioJSResampleControl.outputBuffer;\n            var resampledBuffer = XAudioJSGetArraySlice(resampledResult, resampleLength);\n            this.samplesAlreadyWritten += this.audioHandleMoz.mozWriteAudio(resampledBuffer);\n        }\n    }\n}\nXAudioServer.prototype.callbackBasedWriteAudioNoCallback = function (buffer, upTo) {\n\t//Callback-centered audio APIs:\n    var bufferLength = Math.min(buffer.length, upTo);\n\tfor (var bufferCounter = 0; bufferCounter < bufferLength && XAudioJSAudioBufferSize < XAudioJSMaxBufferSize;) {\n\t\tXAudioJSAudioContextSampleBuffer[XAudioJSAudioBufferSize++] = buffer[bufferCounter++];\n\t}\n}\n/*Pass your samples into here!\nPack your samples as a one-dimenional array\nWith the channel samples packed uniformly.\nexamples:\n    mono - [left, left, left, left]\n    stereo - [left, right, left, right, left, right, left, right]\n*/\nXAudioServer.prototype.writeAudio = function (buffer, upTo) {\n\tswitch (this.audioType) {\n\t\tcase 0:\n\t\t\tthis.MOZWriteAudioNoCallback(buffer, upTo);\n\t\t\tthis.MOZExecuteCallback();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tthis.checkFlashInit();\n\t\tcase 1:\n\t\t\tthis.callbackBasedWriteAudioNoCallback(buffer, upTo);\n\t\t\tthis.callbackBasedExecuteCallback();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthis.failureCallback();\n\t}\n}\n/*Pass your samples into here if you don't want automatic callback calling:\nPack your samples as a one-dimenional array\nWith the channel samples packed uniformly.\nexamples:\n    mono - [left, left, left, left]\n    stereo - [left, right, left, right, left, right, left, right]\nUseful in preventing infinite recursion issues with calling writeAudio inside your callback.\n*/\nXAudioServer.prototype.writeAudioNoCallback = function (buffer, upTo) {\n\tswitch (this.audioType) {\n\t\tcase 0:\n\t\t\tthis.MOZWriteAudioNoCallback(buffer, upTo);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tthis.checkFlashInit();\n\t\tcase 1:\n\t\t\tthis.callbackBasedWriteAudioNoCallback(buffer, upTo);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthis.failureCallback();\n\t}\n}\n//Developer can use this to see how many samples to write (example: minimum buffer allotment minus remaining samples left returned from this function to make sure maximum buffering is done...)\n//If null is returned, then that means metric could not be done.\nXAudioServer.prototype.remainingBuffer = function () {\n\tswitch (this.audioType) {\n\t\tcase 0:\n\t\t\treturn Math.floor((this.samplesAlreadyWritten - this.audioHandleMoz.mozCurrentSampleOffset()) * XAudioJSResampleControl.ratioWeight / XAudioJSChannelsAllocated) * XAudioJSChannelsAllocated;\n\t\tcase 2:\n\t\t\tthis.checkFlashInit();\n\t\tcase 1:\n\t\t\treturn (Math.floor((XAudioJSResampledSamplesLeft() * XAudioJSResampleControl.ratioWeight) / XAudioJSChannelsAllocated) * XAudioJSChannelsAllocated) + XAudioJSAudioBufferSize;\n\t\tdefault:\n\t\t\tthis.failureCallback();\n\t\t\treturn null;\n\t}\n}\nXAudioServer.prototype.MOZExecuteCallback = function () {\n\t//mozAudio:\n\tvar samplesRequested = XAudioJSMinBufferSize - this.remainingBuffer();\n\tif (samplesRequested > 0) {\n        var buffer = this.underRunCallback(samplesRequested);\n\t\tthis.MOZWriteAudioNoCallback(buffer, buffer.length);\n\t}\n}\nXAudioServer.prototype.callbackBasedExecuteCallback = function () {\n\t//WebKit /Flash Audio:\n\tvar samplesRequested = XAudioJSMinBufferSize - this.remainingBuffer();\n\tif (samplesRequested > 0) {\n        var buffer = this.underRunCallback(samplesRequested);\n\t\tthis.callbackBasedWriteAudioNoCallback(buffer, buffer.length);\n\t}\n}\n//If you just want your callback called for any possible refill (Execution of callback is still conditional):\nXAudioServer.prototype.executeCallback = function () {\n\tswitch (this.audioType) {\n\t\tcase 0:\n\t\t\tthis.MOZExecuteCallback();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tthis.checkFlashInit();\n\t\tcase 1:\n\t\t\tthis.callbackBasedExecuteCallback();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthis.failureCallback();\n\t}\n}\n//DO NOT CALL THIS, the lib calls this internally!\nXAudioServer.prototype.initializeAudio = function () {\n    try {\n        this.initializeMozAudio();\n    }\n    catch (error) {\n        try {\n            this.initializeWebAudio();\n        }\n        catch (error) {\n            try {\n                this.initializeFlashAudio();\n            }\n            catch (error) {\n                this.audioType = -1;\n                this.failureCallback();\n            }\n        }\n    }\n}\nXAudioServer.prototype.initializeMozAudio = function () {\n    this.audioHandleMoz = new Audio();\n\tthis.audioHandleMoz.mozSetup(XAudioJSChannelsAllocated, XAudioJSMozAudioSampleRate);\n\tthis.audioHandleMoz.volume = XAudioJSVolume;\n\tthis.samplesAlreadyWritten = 0;\n\tthis.audioType = 0;\n\t//if (navigator.platform != \"MacIntel\" && navigator.platform != \"MacPPC\") {\n\t\t//Add some additional buffering space to workaround a moz audio api issue:\n\t\tvar bufferAmount = (this.XAudioJSSampleRate * XAudioJSChannelsAllocated / 10) | 0;\n\t\tbufferAmount -= bufferAmount % XAudioJSChannelsAllocated;\n\t\tthis.samplesAlreadyWritten -= bufferAmount;\n\t//}\n    this.initializeResampler(XAudioJSMozAudioSampleRate);\n}\nXAudioServer.prototype.initializeWebAudio = function () {\n\tif (typeof AudioContext == \"undefined\" || typeof XAudioJSWebAudioContextHandle == \"undefined\") {\n\t\tthrow null;\n\t}\n\telse {\n\t\tif (!this.userEventLatch) {\n\t\t\tthis.setupWebAudio();\n\t\t}\n\t\telse {\n\t\t\tvar parentObj = this;\n\t\t\tvar XAudioJSWebAudioDelayedEvent = 0;\n\t\t\tthis.userEventLatch.addEventListener(\"click\", function () {\n\t\t\t\tif (XAudioJSWebAudioDelayedEvent == 0) {\n\t\t\t\t\tparentObj.setupWebAudio();\n\t\t\t\t\tXAudioJSWebAudioDelayedEvent |= 1;\n\t\t\t\t}\n\t\t\t}, false);\n\t\t\tthis.userEventLatch.addEventListener(\"touchstart\", function () {\n\t\t\t\tif (XAudioJSWebAudioDelayedEvent < 2) {\n\t\t\t\t\tparentObj.setupWebAudio();\n\t\t\t\t\tXAudioJSWebAudioDelayedEvent |= 2;\n\t\t\t\t}\n\t\t\t}, false);\n\t\t\tthis.userEventLatch.addEventListener(\"touchend\", function () {\n\t\t\t\tif (XAudioJSWebAudioDelayedEvent < 4) {\n\t\t\t\t\tparentObj.setupWebAudio();\n\t\t\t\t\tXAudioJSWebAudioDelayedEvent |= 4;\n\t\t\t\t}\n\t\t\t}, false);\n\t\t\t//TODO: Restructure API to not have to potentially lie to end client about\n\t\t\t//the samples in buffer before user driven event callback that actually starts WA.\n\t\t\tthis.resetCallbackAPIAudioBuffer(44100);\n\t\t}\n\t\tthis.audioType = 1;\n\t}\n}\nXAudioServer.prototype.setupWebAudio = function () {\n\tif (XAudioJSWebAudioLaunchedContext) {\n\t\tXAudioJSWebAudioContextHandle.close();\n\t}\n    try {\n        XAudioJSWebAudioContextHandle = new AudioContext();\t\t\t\t\t\t\t\t//Create a system audio context.\n    }\n    catch (error) {\n       XAudioJSWebAudioContextHandle = new webkitAudioContext();\t\t\t\t\t\t\t//Create a system audio context.\n    }\n    XAudioJSWebAudioLaunchedContext = true;\n    if (XAudioJSWebAudioAudioNode) {\n        XAudioJSWebAudioAudioNode.disconnect();\n        XAudioJSWebAudioAudioNode.onaudioprocess = null;\n        XAudioJSWebAudioAudioNode = null;\n    }\n\tXAudioJSSamplesPerCallback = Math.pow(2, 11 + Math.floor(XAudioJSWebAudioContextHandle.sampleRate / 96000));\n\tXAudioJSMaxBufferSize = Math.max(XAudioJSSamplesPerCallback * XAudioJSChannelsAllocated, XAudioJSMaxBufferSize);\n    try {\n        XAudioJSWebAudioAudioNode = XAudioJSWebAudioContextHandle.createScriptProcessor(XAudioJSSamplesPerCallback, 0, XAudioJSChannelsAllocated);\t//Create the js event node.\n    }\n    catch (error) {\n        XAudioJSWebAudioAudioNode = XAudioJSWebAudioContextHandle.createJavaScriptNode(XAudioJSSamplesPerCallback, 0, XAudioJSChannelsAllocated);\t//Create the js event node.\n    }\n    XAudioJSWebAudioAudioNode.onaudioprocess = XAudioJSWebAudioEvent;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Connect the audio processing event to a handling function so we can manipulate output\n    XAudioJSWebAudioAudioNode.connect(XAudioJSWebAudioContextHandle.destination);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//Send and chain the output of the audio manipulation to the system audio output.\n\tthis.resetCallbackAPIAudioBuffer(XAudioJSWebAudioContextHandle.sampleRate);\n\t/*\n     Firefox has a bug in its web audio implementation...\n     The node may randomly stop playing on Mac OS X for no\n     good reason. Keep a watchdog timer to restart the failed\n     node if it glitches. Google Chrome never had this issue.\n     */\n    XAudioJSWebAudioWatchDogLast = (new Date()).getTime();\n    if (!XAudioJSWebAudioWatchDogTimer && navigator.userAgent.indexOf('Gecko/') > -1) {\n        if (XAudioJSWebAudioWatchDogTimer) {\n            clearInterval(XAudioJSWebAudioWatchDogTimer);\n        }\n        var parentObj = this;\n        XAudioJSWebAudioWatchDogTimer = setInterval(function () {\n\t\t\tif(typeof XAudioJSWebAudioContextHandle.state != \"undefined\") {\n\t\t\t\tif (XAudioJSWebAudioContextHandle.state === 'suspended') {\n\t\t\t\t\tXAudioJSWebAudioWatchDogLast = (new Date()).getTime();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tXAudioJSWebAudioContextHandle.resume();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvar timeDiff = (new Date()).getTime() - XAudioJSWebAudioWatchDogLast;\n\t\t\t\t\tif (timeDiff > 500) {\n\t\t\t\t\t\tparentObj.setupWebAudio();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n        }, 500);\n    }\n}\nXAudioServer.prototype.initializeFlashAudio = function () {\n\tvar existingFlashload = document.getElementById(\"XAudioJS\");\n\tthis.flashInitialized = false;\n\tthis.resetCallbackAPIAudioBuffer(44100);\n\tswitch (XAudioJSChannelsAllocated) {\n\t\tcase 1:\n\t\t\tXAudioJSFlashTransportEncoder = XAudioJSGenerateFlashMonoString;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tXAudioJSFlashTransportEncoder = XAudioJSGenerateFlashStereoString;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tXAudioJSFlashTransportEncoder = XAudioJSGenerateFlashSurroundString;\n\t}\n\tif (existingFlashload == null) {\n\t\tthis.audioHandleFlash = null;\n\t\tvar thisObj = this;\n\t\tvar mainContainerNode = document.createElement(\"div\");\n\t\tmainContainerNode.setAttribute(\"style\", \"position: fixed; bottom: 0px; right: 0px; margin: 0px; padding: 0px; border: none; width: 8px; height: 8px; overflow: hidden; z-index: -1000; \");\n\t\tvar containerNode = document.createElement(\"div\");\n\t\tcontainerNode.setAttribute(\"style\", \"position: static; border: none; width: 0px; height: 0px; visibility: hidden; margin: 8px; padding: 0px;\");\n\t\tcontainerNode.setAttribute(\"id\", \"XAudioJS\");\n\t\tmainContainerNode.appendChild(containerNode);\n\t\tdocument.getElementsByTagName(\"body\")[0].appendChild(mainContainerNode);\n\t\tswfobject.embedSWF(\n\t\t\tXAudioJSsourceHandle.substring(0, XAudioJSsourceHandle.length - 9) + \"JS.swf\",\n\t\t\t\"XAudioJS\",\n\t\t\t\"8\",\n\t\t\t\"8\",\n\t\t\t\"9.0.0\",\n\t\t\t\"\",\n\t\t\t{},\n\t\t\t{\"allowscriptaccess\":\"always\"},\n\t\t\t{\"style\":\"position: static; visibility: hidden; margin: 8px; padding: 0px; border: none\"},\n\t\t\tfunction (event) {\n\t\t\t\tif (event.success) {\n\t\t\t\t\tthisObj.audioHandleFlash = event.ref;\n\t\t\t\t\tthisObj.checkFlashInit();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthisObj.failureCallback();\n\t\t\t\t\tthisObj.audioType = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}\n\telse {\n\t\tthis.audioHandleFlash = existingFlashload;\n\t\tthis.checkFlashInit();\n\t}\n\tthis.audioType = 2;\n}\nXAudioServer.prototype.changeVolume = function (newVolume) {\n\tif (newVolume >= 0 && newVolume <= 1) {\n\t\tXAudioJSVolume = newVolume;\n\t\tswitch (this.audioType) {\n\t\t\tcase 0:\n\t\t\t\tthis.audioHandleMoz.volume = XAudioJSVolume;\n\t\t\tcase 1:\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (this.flashInitialized) {\n\t\t\t\t\tthis.audioHandleFlash.changeVolume(XAudioJSVolume);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.checkFlashInit();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.failureCallback();\n\t\t}\n\t}\n}\n//Checks to see if the NPAPI Adobe Flash bridge is ready yet:\nXAudioServer.prototype.checkFlashInit = function () {\n\tif (!this.flashInitialized) {\n\t\ttry {\n\t\t\tif (this.audioHandleFlash && this.audioHandleFlash.initialize) {\n\t\t\t\tthis.flashInitialized = true;\n\t\t\t\tthis.audioHandleFlash.initialize(XAudioJSChannelsAllocated, XAudioJSVolume);\n\t\t\t}\n\t\t}\n\t\tcatch (error) {\n\t\t\tthis.flashInitialized = false;\n\t\t}\n\t}\n}\n//Set up the resampling:\nXAudioServer.prototype.resetCallbackAPIAudioBuffer = function (APISampleRate) {\n\tXAudioJSAudioBufferSize = XAudioJSResampleBufferEnd = XAudioJSResampleBufferStart = 0;\n    this.initializeResampler(APISampleRate);\n    XAudioJSResampledBuffer = this.getFloat32(XAudioJSResampleBufferSize);\n}\nXAudioServer.prototype.initializeResampler = function (sampleRate) {\n    XAudioJSAudioContextSampleBuffer = this.getFloat32(XAudioJSMaxBufferSize);\n\tXAudioJSResampleControl = new Resampler(this.XAudioJSSampleRate, sampleRate, XAudioJSChannelsAllocated, XAudioJSAudioContextSampleBuffer);\n    XAudioJSResampleBufferSize = XAudioJSResampleControl.outputBuffer.length;\n}\nXAudioServer.prototype.getFloat32 = function (size) {\n\ttry {\n\t\treturn new Float32Array(size);\n\t}\n\tcatch (error) {\n\t\treturn [];\n\t}\n}\nfunction XAudioJSFlashAudioEvent() {\t\t//The callback that flash calls...\n    XAudioJSCallbackAPIEventNotificationCallbackCompatTimerClear();\n\tXAudioJSCallbackAPIEventNotification();\n    XAudioJSResampleRefill();\n\tvar outputStr = XAudioJSFlashTransportEncoder();\n    XAudioJSCallbackAPIEventNotification2();\n    return outputStr;\n}\nfunction XAudioJSGenerateFlashSurroundString() {\t//Convert the arrays to one long string for speed.\n\tvar XAudioJSTotalSamples = XAudioJSSamplesPerCallback << 1;\n\tif (XAudioJSBinaryString.length > XAudioJSTotalSamples) {\n\t\tXAudioJSBinaryString = [];\n\t}\n\tXAudioJSTotalSamples = 0;\n\tfor (var index = 0; index < XAudioJSSamplesPerCallback && XAudioJSResampleBufferStart != XAudioJSResampleBufferEnd; ++index) {\n\t\t//Sanitize the buffer:\n\t\tXAudioJSBinaryString[XAudioJSTotalSamples++] = String.fromCharCode(((Math.min(Math.max(XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] + 1, 0), 2) * 0x3FFF) | 0) + 0x3000);\n\t\tXAudioJSBinaryString[XAudioJSTotalSamples++] = String.fromCharCode(((Math.min(Math.max(XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] + 1, 0), 2) * 0x3FFF) | 0) + 0x3000);\n\t\tXAudioJSResampleBufferStart += XAudioJSChannelsAllocated - 2;\n\t\tif (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {\n\t\t\tXAudioJSResampleBufferStart = 0;\n\t\t}\n\t}\n\treturn XAudioJSBinaryString.join(\"\");\n}\nfunction XAudioJSGenerateFlashStereoString() {\t//Convert the arrays to one long string for speed.\n\tvar XAudioJSTotalSamples = XAudioJSSamplesPerCallback << 1;\n\tif (XAudioJSBinaryString.length > XAudioJSTotalSamples) {\n\t\tXAudioJSBinaryString = [];\n\t}\n\tfor (var index = 0; index < XAudioJSTotalSamples && XAudioJSResampleBufferStart != XAudioJSResampleBufferEnd;) {\n\t\t//Sanitize the buffer:\n\t\tXAudioJSBinaryString[index++] = String.fromCharCode(((Math.min(Math.max(XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] + 1, 0), 2) * 0x3FFF) | 0) + 0x3000);\n\t\tXAudioJSBinaryString[index++] = String.fromCharCode(((Math.min(Math.max(XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] + 1, 0), 2) * 0x3FFF) | 0) + 0x3000);\n\t\tif (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {\n\t\t\tXAudioJSResampleBufferStart = 0;\n\t\t}\n\t}\n\treturn XAudioJSBinaryString.join(\"\");\n}\nfunction XAudioJSGenerateFlashMonoString() {\t//Convert the array to one long string for speed.\n\tif (XAudioJSBinaryString.length > XAudioJSSamplesPerCallback) {\n\t\tXAudioJSBinaryString = [];\n\t}\n\tfor (var index = 0; index < XAudioJSSamplesPerCallback && XAudioJSResampleBufferStart != XAudioJSResampleBufferEnd;) {\n\t\t//Sanitize the buffer:\n\t\tXAudioJSBinaryString[index++] = String.fromCharCode(((Math.min(Math.max(XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] + 1, 0), 2) * 0x3FFF) | 0) + 0x3000);\n\t\tif (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {\n\t\t\tXAudioJSResampleBufferStart = 0;\n\t\t}\n\t}\n\treturn XAudioJSBinaryString.join(\"\");\n}\n//Some Required Globals:\nvar XAudioJSWebAudioContextHandle = null;\nvar XAudioJSWebAudioAudioNode = null;\nvar XAudioJSWebAudioWatchDogTimer = null;\nvar XAudioJSCallbackAPIEventNotificationCallback = null;\nvar XAudioJSCallbackAPIEventNotificationCallback2 = null;\nvar XAudioJSCallbackAPIEventNotificationCallbackCompatTimer = setInterval(XAudioJSCallbackAPIEventNotificationDual, 16);\nvar XAudioJSWebAudioWatchDogLast = false;\nvar XAudioJSWebAudioLaunchedContext = false;\nvar XAudioJSAudioContextSampleBuffer = [];\nvar XAudioJSResampledBuffer = [];\nvar XAudioJSMinBufferSize = 15000;\nvar XAudioJSMaxBufferSize = 25000;\nvar XAudioJSChannelsAllocated = 1;\nvar XAudioJSVolume = 1;\nvar XAudioJSResampleControl = null;\nvar XAudioJSAudioBufferSize = 0;\nvar XAudioJSResampleBufferStart = 0;\nvar XAudioJSResampleBufferEnd = 0;\nvar XAudioJSResampleBufferSize = 0;\nvar XAudioJSMozAudioSampleRate = 44100;\nvar XAudioJSSamplesPerCallback = 2048;\t\t\t//Has to be between 2048 and 4096 (If over, then samples are ignored, if under then silence is added).\nvar XAudioJSFlashTransportEncoder = null;\nvar XAudioJSBinaryString = [];\nfunction XAudioJSWebAudioEvent(event) {\t\t//Web Audio API callback...\n\tif (XAudioJSWebAudioWatchDogTimer) {\n\t\tXAudioJSWebAudioWatchDogLast = (new Date()).getTime();\n\t}\n\t//Find all output channels:\n\tfor (var bufferCount = 0, buffers = []; bufferCount < XAudioJSChannelsAllocated; ++bufferCount) {\n\t\tbuffers[bufferCount] = event.outputBuffer.getChannelData(bufferCount);\n\t}\n    XAudioJSCallbackAPIEventNotificationCallbackCompatTimerClear();\n\tXAudioJSCallbackAPIEventNotification();\n    //Make sure we have resampled samples ready:\n\tXAudioJSResampleRefill();\n\t//Copy samples from XAudioJS to the Web Audio API:\n\tfor (var index = 0; index < XAudioJSSamplesPerCallback && XAudioJSResampleBufferStart != XAudioJSResampleBufferEnd; ++index) {\n\t\tfor (bufferCount = 0; bufferCount < XAudioJSChannelsAllocated; ++bufferCount) {\n\t\t\tbuffers[bufferCount][index] = XAudioJSResampledBuffer[XAudioJSResampleBufferStart++] * XAudioJSVolume;\n\t\t}\n\t\tif (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {\n\t\t\tXAudioJSResampleBufferStart = 0;\n\t\t}\n\t}\n\t//Pad with silence if we're underrunning:\n\twhile (index < XAudioJSSamplesPerCallback) {\n\t\tfor (bufferCount = 0; bufferCount < XAudioJSChannelsAllocated; ++bufferCount) {\n\t\t\tbuffers[bufferCount][index] = 0;\n\t\t}\n\t\t++index;\n\t}\n    XAudioJSCallbackAPIEventNotification2();\n}\nfunction XAudioJSResampleRefill() {\n\tif (XAudioJSAudioBufferSize > 0) {\n\t\t//Resample a chunk of audio:\n\t\tvar resampleLength = XAudioJSResampleControl.resampler(XAudioJSAudioBufferSize);\n\t\tvar resampledResult = XAudioJSResampleControl.outputBuffer;\n\t\tfor (var index2 = 0; index2 < resampleLength;) {\n\t\t\tXAudioJSResampledBuffer[XAudioJSResampleBufferEnd++] = resampledResult[index2++];\n\t\t\tif (XAudioJSResampleBufferEnd == XAudioJSResampleBufferSize) {\n\t\t\t\tXAudioJSResampleBufferEnd = 0;\n\t\t\t}\n\t\t\tif (XAudioJSResampleBufferStart == XAudioJSResampleBufferEnd) {\n\t\t\t\tXAudioJSResampleBufferStart += XAudioJSChannelsAllocated;\n\t\t\t\tif (XAudioJSResampleBufferStart == XAudioJSResampleBufferSize) {\n\t\t\t\t\tXAudioJSResampleBufferStart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tXAudioJSAudioBufferSize = 0;\n\t}\n}\nfunction XAudioJSCallbackAPIEventNotificationCallbackCompatTimerClear() {\n    if (XAudioJSCallbackAPIEventNotificationCallbackCompatTimer) {\n        clearInterval(XAudioJSCallbackAPIEventNotificationCallbackCompatTimer);\n    }\n}\nfunction XAudioJSCallbackAPIEventNotification() {\n    if (typeof XAudioJSCallbackAPIEventNotificationCallback == \"function\") {\n        XAudioJSCallbackAPIEventNotificationCallback();\n    }\n}\nfunction XAudioJSCallbackAPIEventNotification2() {\n    if (typeof XAudioJSCallbackAPIEventNotificationCallback2 == \"function\") {\n        XAudioJSCallbackAPIEventNotificationCallback2();\n    }\n}\nfunction XAudioJSCallbackAPIEventNotificationDual() {\n    XAudioJSCallbackAPIEventNotification();\n    XAudioJSCallbackAPIEventNotification2();\n}\nfunction XAudioJSResampledSamplesLeft() {\n\treturn ((XAudioJSResampleBufferStart <= XAudioJSResampleBufferEnd) ? 0 : XAudioJSResampleBufferSize) + XAudioJSResampleBufferEnd - XAudioJSResampleBufferStart;\n}\nfunction XAudioJSGetArraySlice(buffer, lengthOf) {\n\t//Typed array and normal array buffer section referencing:\n\ttry {\n\t\treturn buffer.subarray(0, lengthOf);\n\t}\n\tcatch (error) {\n\t\ttry {\n\t\t\t//Regular array pass:\n\t\t\tbuffer.length = lengthOf;\n\t\t\treturn buffer;\n\t\t}\n\t\tcatch (error) {\n\t\t\t//Nightly Firefox 4 used to have the subarray function named as slice:\n\t\t\treturn buffer.slice(0, lengthOf);\n\t\t}\n\t}\n}"],"names":["XAudioJSscriptsHandle","document","getElementsByTagName","XAudioJSsourceHandle","length","src","XAudioServer","channels","sampleRate","minBufferSize","maxBufferSize","underRunCallback","heartbeatCallback","postheartbeatCallback","volume","failureCallback","userEventLatch","XAudioJSChannelsAllocated","Math","max","this","XAudioJSSampleRate","abs","XAudioJSMinBufferSize","XAudioJSSamplesPerCallback","XAudioJSMaxBufferSize","floor","XAudioJSCallbackAPIEventNotificationCallback","XAudioJSCallbackAPIEventNotificationCallback2","XAudioJSVolume","Error","initializeAudio","XAudioJSFlashAudioEvent","XAudioJSCallbackAPIEventNotificationCallbackCompatTimerClear","XAudioJSCallbackAPIEventNotification","XAudioJSResampleRefill","outputStr","XAudioJSFlashTransportEncoder","XAudioJSCallbackAPIEventNotification2","XAudioJSGenerateFlashSurroundString","XAudioJSTotalSamples","XAudioJSBinaryString","index","XAudioJSResampleBufferStart","XAudioJSResampleBufferEnd","String","fromCharCode","min","XAudioJSResampledBuffer","XAudioJSResampleBufferSize","join","XAudioJSGenerateFlashStereoString","XAudioJSGenerateFlashMonoString","prototype","MOZWriteAudioNoCallback","buffer","upTo","bufferLength","bufferIndex","sliceLength","sliceIndex","XAudioJSAudioContextSampleBuffer","resampleLength","XAudioJSResampleControl","resampler","resampledBuffer","XAudioJSGetArraySlice","outputBuffer","samplesAlreadyWritten","audioHandleMoz","mozWriteAudio","callbackBasedWriteAudioNoCallback","bufferCounter","XAudioJSAudioBufferSize","writeAudio","audioType","MOZExecuteCallback","checkFlashInit","callbackBasedExecuteCallback","writeAudioNoCallback","remainingBuffer","mozCurrentSampleOffset","ratioWeight","XAudioJSResampledSamplesLeft","samplesRequested","executeCallback","initializeMozAudio","error2","initializeWebAudio","error1","initializeFlashAudio","error","Audio","mozSetup","XAudioJSMozAudioSampleRate","bufferAmount","initializeResampler","AudioContext","XAudioJSWebAudioContextHandle","parentObj","XAudioJSWebAudioDelayedEvent","addEventListener","setupWebAudio","resetCallbackAPIAudioBuffer","XAudioJSWebAudioLaunchedContext","close","webkitAudioContext","XAudioJSWebAudioAudioNode","disconnect","onaudioprocess","pow","createScriptProcessor","createJavaScriptNode","XAudioJSWebAudioEvent","connect","destination","XAudioJSWebAudioWatchDogLast","Date","getTime","XAudioJSWebAudioWatchDogTimer","navigator","userAgent","indexOf","clearInterval","setInterval","state","resume","e","existingFlashload","getElementById","flashInitialized","audioHandleFlash","thisObj","mainContainerNode","createElement","setAttribute","containerNode","appendChild","swfobject","embedSWF","substring","allowscriptaccess","style","event","success","ref","changeVolume","newVolume","initialize","APISampleRate","getFloat32","Resampler","size","Float32Array","XAudioJSCallbackAPIEventNotificationCallbackCompatTimer","XAudioJSCallbackAPIEventNotificationDual","bufferCount","buffers","getChannelData","resampledResult","index2","lengthOf","subarray","slice"],"version":3,"file":"build-index.1e28e52f.js.map"}