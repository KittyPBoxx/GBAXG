{"mappings":"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","sources":["dist/Randomiser/Randomisation.js"],"sourcesContent":["var mixedGameData = {};\nObject.entries(FIRE_RED_WARPS).forEach(e => mixedGameData[e[0]] = e[1]);\nObject.entries(CRYSTAL_WARPS).forEach(e => mixedGameData[e[0]] = e[1]);\nObject.entries(EMERALD_WARPS).forEach(e => mixedGameData[e[0]] = e[1]);\n\nvar remappingsData = {};\nvar isHeadless = true;\n\n// WarpList used by EmulationCoreHacks.js\nvar warpList = new Map();\n\nfunction getMapData() {\n    return mixedGameData;\n}\n\nfunction getRandomisationAlgorithm() {\n    return generateRandomMappings;\n}\n\nfunction getRandomisationConfig() {\n    let config = {};\n    config.kantoLevel = document.getElementById(\"kantoLevel\").value;\n    config.johtoLevel = document.getElementById(\"johtoLevel\").value;\n    config.hoennLevel = document.getElementById(\"hoennLevel\").value;\n    return config;\n}\n\nfunction getFlagData() {\n  return FLAG_DATA;\n}\n\nfunction mappingToWarps(mappingData) {\n    let mappedList = new Map();\n\n    mappingData.forEach(mapping => {\n        let from = mapping.trigger;\n        let to = mapping.target;\n        let toParts = to.split(\",\");\n        mappedList.set(from, new PKWarp(from, toParts[0], toParts[1], toParts[2], toParts[3], mapping.source));\n    });\n\n    return mappedList;\n}\n\nasync function mapWarps(seed) {\n\n    flagsState = {};\n    unaddedConditionalEdges = {};\n\n    let config = getRandomisationConfig();\n    let mapData = getFilteredData();\n    let flagData = getFlagData()\n    remappingsData = getRandomisationAlgorithm().apply(null, [seed, mapData, flagData, config]);\n    warpList = mappingToWarps(getAugmetedRemappingData(remappingsData));\n    updateHashDisplay();\n\n    if (typeof storageManager !== 'undefined') {\n      storageManager.persist(\"RANDOM_MAPPING\", new WarpListData(seed, config, warpList));\n    }\n}\n\nfunction generateRandomMappings(seed, mapData, flagData, config) {\n    \n    let rng = new RNG(getHash(seed));\n    let progressionState = initMappingGraph(mapData, isHeadless, new ProgressionState(flagData, config))\n\n    var root = getInitialWarp(config);\n\n    progressionState.unconnectedComponents = progressionState.unconnectedComponents.filter(a => !a.includes(root));\n\n    var moreWarpsToMap = true;\n    while(moreWarpsToMap) {\n        moreWarpsToMap = doNextMapping(rng, root, progressionState);\n        progressionState = updateProgressionState(progressionState, root);\n    }\n\n    // Add each games bedrooms and make sure they map to house in pallet town\n    cy.add(new WarpNode(['C,1,1,0' , getMapData()[\"C,1,1,0\" ]]));\n    cy.add(new WarpNode(['E,1,3,0' , getMapData()[\"E,1,3,0\" ]]));\n    cy.add(new WarpNode(['FR,4,0,2', getMapData()[\"FR,4,0,2\"]]));\n\n    window.cy.add(new WarpEdge('C,1,1,0', 'FR,4,0,2'));\n    window.cy.add(new WarpEdge('E,1,3,0', 'FR,4,0,2'));\n\n   return getBaseRemappingData();\n}\n\nfunction getInitialWarp(config) {\n  if (config.kantoLevel > 0) {\n    return KEY_LOCATION_DATA[\"VIRIDIAN CITY\"];\n  }\n  if (config.johtoLevel > 0) {\n    return KEY_LOCATION_DATA[\"NEW BARK TOWN\"];\n  }\n  if (config.hoennLevel > 0) {\n    return KEY_LOCATION_DATA[\"LITTLEROOT TOWN\"];\n  }\n  return KEY_LOCATION_DATA[\"VIRIDIAN CITY\"];\n}\n\nfunction filterIgnored(mapData) {\n    return new Map([...mapData].filter(k => !k[1].ignore));\n}\n\nfunction filterByConfig(usabledWarps, config) {\n    usabledWarps = new Map([...usabledWarps].filter(w => {\n        let filterLevel = null;\n        if (w[0][0] == \"E\") {\n            filterLevel = config.hoennLevel;\n        } else if (w[0][0] == \"F\") {\n            filterLevel = config.kantoLevel;\n        } else if (w[0][0] == \"C\") {\n            filterLevel = config.johtoLevel;\n        }\n\n        return usabledWarps.get(w[0]).level && (+usabledWarps.get(w[0]).level <= +filterLevel);\n    }));\n    return usabledWarps;\n}\n\nfunction filteGroupedNotMain(mapData) {\n    return new Map([...mapData].filter(k => k[1].groupMain || !k[1].grouped));\n} \n\nfunction toMapBank(s) { \n    let arr = s.split(\",\"); \n    return arr[0] + \",\" + arr[1] + \",\" + arr[2] \n}\n\nfunction ProgressionState(flagData, config) {\n  this.remainingConditionalEdges = new Set();\n  this.flags = new Set();\n  this.flagData = flagData;\n  this.config = config;\n  // Locations that may grant further progress\n  this.unmarkedLocations = new Map(Object.entries(flagData.LOCATIONS_TRIGGER));\n  this.unmarkedFlags = new Map(Object.entries(flagData.COMPOSITE_FLAGS));\n  // Locations that will not grant progress but should be included anyway\n  this.unmarkedKeyLocations = new Map(Object.entries(flagData.KEY_LOCATIONS))\n}\n\nProgressionState.prototype.makeFinalLocationsKey = function (config) {\n\n  let finalLocations = [];\n\n  switch(this.config.kantoLevel) {\n    case \"1\": finalLocations.push(HINTABLE_LOCATIONS[\"BROCK\"])   ; break;\n    case \"2\": finalLocations.push(HINTABLE_LOCATIONS[\"MISTY\"])   ; break;\n    case \"3\": finalLocations.push(HINTABLE_LOCATIONS[\"LT SURGE\"]); break; \n    case \"4\": finalLocations.push(HINTABLE_LOCATIONS[\"ERIKA\"])   ; break;\n    case \"5\": finalLocations.push(HINTABLE_LOCATIONS[\"KOGA\"])    ; break;\n    case \"6\": finalLocations.push(HINTABLE_LOCATIONS[\"SABRIBA\"]) ; break;\n    case \"7\": finalLocations.push(HINTABLE_LOCATIONS[\"BLAINE\"])  ; break;\n    case \"8\": finalLocations.push(HINTABLE_LOCATIONS[\"GIOVANNI\"]); break;\n    case \"9\": \n    case \"0\": \n    case \"10\":\n    default: \n      // E4 and upwards are key locations not progression anyway  \n      break;\n  }\n\n  switch(this.config.johtoLevel) {\n    case \"1\": finalLocations.push(HINTABLE_LOCATIONS[\"FALKNER\"]); break;\n    case \"2\": finalLocations.push(HINTABLE_LOCATIONS[\"BUGSY\"])  ; break;\n    case \"3\": finalLocations.push(HINTABLE_LOCATIONS[\"WHITNEY\"]); break; \n    case \"4\": finalLocations.push(HINTABLE_LOCATIONS[\"MORTY\"])  ; break;\n    case \"5\": finalLocations.push(HINTABLE_LOCATIONS[\"CHUCK\"])  ; break;\n    case \"6\": finalLocations.push(HINTABLE_LOCATIONS[\"JASMINE\"]); break;\n    case \"7\": finalLocations.push(HINTABLE_LOCATIONS[\"PRYCE\"])  ; break;\n    case \"8\": finalLocations.push(HINTABLE_LOCATIONS[\"CLAIR\"])  ; break;\n    case \"9\": \n    case \"0\": \n    case \"10\": \n    default:\n      // E4 and upwards are key locations not progression anyway  \n      break;\n  }\n\n  switch(this.config.hoennLevel) {\n    case \"1\": finalLocations.push(HINTABLE_LOCATIONS[\"ROXANNE\"])      ; break;\n    case \"2\": finalLocations.push(HINTABLE_LOCATIONS[\"BRAWLY\"])       ; break;\n    case \"3\": finalLocations.push(HINTABLE_LOCATIONS[\"WATTSON\"])      ; break; \n    case \"4\": finalLocations.push(HINTABLE_LOCATIONS[\"FLANNERY\"])     ; break;\n    case \"5\": finalLocations.push(HINTABLE_LOCATIONS[\"NORMAN\"])       ; break;\n    case \"6\": finalLocations.push(HINTABLE_LOCATIONS[\"WINONA\"])       ; break;\n    case \"7\": finalLocations.push(HINTABLE_LOCATIONS[\"TATE AND LIZA\"]); break;\n    case \"8\": finalLocations.push(HINTABLE_LOCATIONS[\"JUAN\"])         ; break;\n    case \"9\": \n    case \"0\": \n    case \"10\": \n    default:\n      // E4 and upwards are key locations not progression anyway  \n      break;\n  }\n\n  finalLocations.forEach(l => {\n    if (this.unmarkedLocations.has(l)) {\n      this.unmarkedKeyLocations.set(l, this.unmarkedLocations.get(l))\n      this.unmarkedLocations.delete(l);\n    }\n  })\n\n}\n\n/** \n *  Warp data model\n */\nfunction WarpListData(seed, config, warpList) {\n  this.warpList = Array.from(warpList.entries());\n  this.seed = seed;\n  this.config = config;\n} \n\nfunction exportMapping() {\n  storageManager.find(\"RANDOM_MAPPING\").then(s => {\n      let data = JSON.stringify(s);\n      let file = new File([data], \"WarpMapping.json\", {type: \"application/json;charset=utf-8\"});\n      saveAs(file);\n  });\n}\n\nfunction importMapping() {\n  let file = this.files[0];\n\n  let reader = new FileReader();\n  reader.readAsText(file,'UTF-8');\n\n  reader.onload = readerEvent => {\n      let content = readerEvent.target.result;\n      let warpListData = JSON.parse(content);\n      updateWarpListData(warpListData);\n      storageManager.persist(\"RANDOM_MAPPING\", warpListData);\n   }\n}\n\nfunction updateWarpListData(warpListData) {\n  document.getElementById(\"input_seed_text\").value = warpListData.seed;\n\n  document.getElementById(\"kantoLevel\").value = warpListData.config.kantoLevel;\n  document.getElementById(\"johtoLevel\").value = warpListData.config.johtoLevel || warpListData.config.jhotoLevel; // needed for old seed files generated while the name was misspelt\n  document.getElementById(\"hoennLevel\").value = warpListData.config.hoennLevel;\n  M.FormSelect.getInstance(document.getElementById(\"kantoLevel\"))._handleSelectChangeBound();\n  M.FormSelect.getInstance(document.getElementById(\"johtoLevel\"))._handleSelectChangeBound();\n  M.FormSelect.getInstance(document.getElementById(\"hoennLevel\"))._handleSelectChangeBound();\n\n  warpList = new Map(warpListData.warpList);\n  updateHashDisplay();\n}\n\nfunction updateHashDisplay() {\n  document.getElementById(\"hashText\").innerHTML = \"CHECK: \" + Math.abs(getHash(JSON.stringify(Array.from(warpList)))).toString(16).toUpperCase();\n}\n\n/**\n *  Warp Script model \n */\n function PKWarp(trigger, romCode, bank, map, warpNo, source) {\n    this.trigger = trigger;\n    this.toRomCode = romCode;\n    this.toBank = bank;\n    this.toMap = map;\n    this.toWarpNo = warpNo;\n    this.source = source;\n}\n\n/**\n *  SEEDED RNG MANAGEMENT\n */\n\nfunction getHash(input){\n    var hash = 0, len = input.length;\n    for (var i = 0; i < len; i++) {\n      hash  = ((hash << 5) - hash) + input.charCodeAt(i);\n      hash |= 0; // to 32bit integer\n    }\n    return hash;\n}\n\nfunction RNG(seed) {\n    // LCG using GCC's constants\n    this.m = 0x80000000; // 2**31;\n    this.a = 1103515245;\n    this.c = 12345;\n  \n    this.state = seed ? seed : Math.floor(Math.random() * (this.m - 1));\n}\nRNG.prototype.nextInt = function() {\n  this.state = (this.a * this.state + this.c) % this.m;\n  return this.state;\n}\nRNG.prototype.nextFloat = function() {\n  // returns in range [0,1]\n  return this.nextInt() / (this.m - 1);\n}\nRNG.prototype.nextRange = function(start, end) {\n  // returns in range [start, end): including start, excluding end\n  // can't modulu nextInt because of weak randomness in lower bits\n  var rangeSize = end - start;\n  var randomUnder1 = this.nextInt() / this.m;\n  return Math.abs(start + Math.floor(randomUnder1 * rangeSize));\n}\nRNG.prototype.choice = function(array) {\n  return array[this.nextRange(0, array.length)];\n}\n\n/**\n *  GRAPHING / CONNECTION MANAGEMENT\n */\n\n function ReigonNode(id) {\n    this.data = {};\n    this.data.id = id;\n    this.classes = 'reigon';\n}\n\nfunction AreaNode(node) {\n    this.data = {};\n    this.data.id = toMapBank(node[0]);\n    this.data.parent = toReigon(node[0]);\n    this.data.label = node[0] + \" (\" + node[1].name.split(\"-\")[0] + \"- \" + node[1].name.split(\"-\")[1].trim() + \")\";\n}\n\nfunction WarpNode(data) {\n    this.data = {};\n    this.data.id = data[0];\n    this.data.parent = toMapBank(data[0]);\n    this.data.label = data[1].name ? data[0] + data[1].name.split(\"-\")[2] : data[0] + \" (Unnamed)\";\n    this.classes = 'outline';\n    this.data.isWarp = true;\n    this.data.isMapped = false;\n    this.data.hasMultipleConnections = data[1].connections ? Object.values(data[1].connections).filter(n => n == true).length > 0 : false;\n}\n\nfunction FixedEdge(source, target) {\n    this.data = {};\n    this.data.id = source + \"->\" + target;\n    this.data.source = source;\n    this.data.target = target;\n    this.classes = 'fixed';\n}\n\nfunction CondidtionalEdge(source, target, condition) {\n  this.data = {};\n  this.data.id = source + \"->\" + target;\n  this.data.source = source;\n  this.data.target = target;\n  this.classes = 'conditional';\n  this.condition = condition;\n}\n\nfunction WarpEdge(source, target, count) {\n  this.data = {};\n  this.data.id = source + \"->\" + target + \"#\" + window.cy.getElementById(source + \"->\" + target).length;\n  this.data.source = source;\n  this.data.target = target;\n  this.data.isWarp = true;\n  this.classes = 'warp';\n}\n\nfunction getAugmetedRemappingData(remappingData) {\n\n  remappingData = addGroupedMappings(remappingData);\n  remappingData = addTriggerData(remappingData);\n\n  return remappingData;\n}\n\nfunction addGroupedMappings(remappingData) {\n  \n  let groupMappings = [];\n\n  remappingData.forEach(m => {\n    let groups = getMapData()[m.source].grouped;\n    if (groups) {\n      groups.forEach(g => {\n        groupMappings.push({source: g, target: m.target});\n      });\n    }\n  })\n\n  return [...remappingData, ...groupMappings];\n}\n\nfunction addTriggerData(remappingData) {\n\n  return remappingData.map(m => {\n    m.trigger = getMapData()[m.source].to;\n    return m;\n  });\n\n}\n\nfunction getBaseRemappingData() {\n  return cy.edges().filter(e => e.data().isWarp).map(e => { return {source: e.data().source, target: e.data().target} });\n}\n\nfunction getFilteredData() {\n    let warpIdData = new Map(Object.entries(getMapData()));\n    warpIdData = filterIgnored(warpIdData);\n    warpIdData = filteGroupedNotMain(warpIdData);\n    warpIdData = filterByConfig(warpIdData, getRandomisationConfig());\n    return warpIdData;\n}\n\nfunction toReigon(id) {\n    switch(id[0]) {\n        case 'F': return 'KANTO'\n        case 'C': return 'JOHTO'\n        case 'E': return 'HOENN'\n    }\n}\n\nfunction findAccessibleUnmappedNodes(cy, root) {\n  let nodeSet = new Set();\n  cy.elements().bfs({roots: cy.getElementById(root), directed: true, visit: (v, e, u, i, depth) => {\n    \n    if(!v.data().isMapped) {\n      nodeSet.add(v)\n    }\n\n  }});\n  return nodeSet;\n}\n\nfunction doNextMapping(rng, root, progressionState) {\n    let accessibleNodes = progressionState.cachedNodes ? progressionState.cachedNodes : findAccessibleUnmappedNodes(window.cy, root);\n    let inacessibleNodes = cy.nodes().not(accessibleNodes).filter(e => e.data().isWarp && !e.data().isMapped);\n    let inaccesibleFlagLocations = inacessibleNodes.filter(n => progressionState.unmarkedLocations.has(n.data().id));\n    let inaccesibleKeyLocations = inacessibleNodes.filter(n => progressionState.unmarkedLocations.has(n.data().id));\n\n    if(accessibleNodes.size == 0 && inacessibleNodes.length == 0) { \n      return false; \n    }\n\n    let warp1 = [...accessibleNodes][rng.nextRange(0, accessibleNodes.size - 1)];\n    accessibleNodes.delete(warp1);\n    \n    let warp2 = null;\n    let shouldCacheNodes = false;\n    let inacessibleHubs = inacessibleNodes.filter(e => e.degree(true) > 0);\n    if (progressionState.unconnectedComponents.length > 0) {\n\n      // Add a node from every component of the graph (with the assumption no warps are present but all flags are met)\n      let randomComponent = progressionState.unconnectedComponents[rng.nextRange(0, progressionState.unconnectedComponents.length - 1)];\n      let randomNodeIdFromComponent = randomComponent[rng.nextRange(0, randomComponent.length - 1)];\n\n      warp2 = cy.getElementById(randomNodeIdFromComponent);\n      progressionState.unconnectedComponents = progressionState.unconnectedComponents.filter(c => c != randomComponent);\n\n    } else if (inaccesibleFlagLocations.length > 0) { \n\n      // Add inacessible dead-ends that might allow flags givinb access to new locations\n      warp2 = inaccesibleFlagLocations[rng.nextRange(0, inaccesibleFlagLocations.length - 1)];\n\n    } else if (inacessibleHubs.length > 0) {\n\n      // Add any hubs that there is still no access to... I'm not sure there would even be any left...\n      inacessibleNodes = inacessibleNodes.filter(e => e.degree(true) > 0);\n      warp2 = inacessibleNodes[rng.nextRange(0, inacessibleNodes.length - 1)];\n\n    } else if (inaccesibleKeyLocations.length > 0) {\n\n      // Add key inacessible locations \n      warp2 = inaccesibleKeyLocations[rng.nextRange(0, inaccesibleKeyLocations.length - 1)];\n      shouldCacheNodes = true;\n      accessibleNodes.delete(warp2);\n    } else if (inacessibleNodes.length > 0) {\n\n      // Add other inacessible dead-ends \n      warp2 = inacessibleNodes[rng.nextRange(0, inacessibleNodes.length - 1)];\n      shouldCacheNodes = true;\n      accessibleNodes.delete(warp2);\n\n    } else if (accessibleNodes.size > 0) {\n\n      // map together nodes that are already accessible\n      warp2 = [...accessibleNodes][rng.nextRange(0, accessibleNodes.size - 1)];\n      shouldCacheNodes = true;\n      accessibleNodes.delete(warp2);\n\n    } else {\n      //console.warn(\"Unevenly matched warps. \" + warp1.data().id + \" had to map to itself\");\n      // warp2 = warp1\n\n      // if one warp is left hanging we connect it to altering cave from fire red\n      warp2 = cy.add(new WarpNode(['FR,1,122,0', getMapData()[\"FR,1,122,0\"]]));\n      shouldCacheNodes = true;\n      accessibleNodes.delete(warp2);\n\n    }\n\n    // Once it's only dead ends left we can cache which nodes are accessible from the root \n    if (shouldCacheNodes && !progressionState.cachedNodes) {\n        progressionState.cachedNodes = accessibleNodes;\n    }\n\n    if (!warp1) {\n      \n      if (accessibleNodes.size != 0) {\n        console.log(\"Some accessible nodes were left:\")\n        accessibleNodes.forEach(n => {\n          console.log(n.data().id)\n        })\n      } else {\n        console.log(\"All accesible nodes mapped\")\n      }\n\n      if (inacessibleNodes.size != 0) {\n        console.log(\"Some inaccessible nodes were left:\")\n        inacessibleNodes.forEach(n => {\n          console.log(n.data().id)\n        })\n\n        warp2.data().isMapped = true;\n        return false;\n\n      } else {\n        console.log(\"All inaccesible nodes mapped\")\n      }\n\n    }\n\n    window.cy.add(new WarpEdge(warp1.data().id, warp2.data().id))\n\n    if (warp1 != warp2) {\n          window.cy.add(new WarpEdge(warp2.data().id, warp1.data().id))\n    }\n    \n    warp1.data().isMapped = true;\n    warp2.data().isMapped = true;\n\n    return true;\n}\n\n\nfunction updateProgressionState(updateProgressionState, root) {\n\n  let currentNodes = new Set();\n  cy.elements().bfs({roots: cy.getElementById(root), directed: true, visit: (v, e, u, i, depth) => { \n    currentNodes.add(v.data().id) \n  }});\n\n  updateProgressionState.unmarkedLocations.forEach((name, location) => {\n    if (currentNodes.has(location)) {\n      updateProgressionState.unmarkedLocations.delete(location);\n      updateProgressionState.flags.add(name);\n    }\n  });\n\n  updateProgressionState.unmarkedFlags.forEach(n => {\n    if (n.condition.every(flag => updateProgressionState.flags.has(flag))) {\n      updateProgressionState.flags.add(n.flag);\n      updateProgressionState.unmarkedFlags.delete(n.flag)\n    }\n  });\n\n  let conditionalEdges = updateProgressionState.remainingConditionalEdges;\n  conditionalEdges.forEach(e => {\n    if (updateProgressionState.flags.has(e.condition)) {\n      if (cy.getElementById(e.data.target).length > 0 && cy.getElementById(e.data.source).length > 0) {\n        cy.add(e);\n      }\n      conditionalEdges.delete(e);\n    }\n  });\n\n  return updateProgressionState;\n}\n\nfunction initMappingGraph(mapData, isHeadless, progressionState) {\n\n  var cy = window.cy = cytoscape({\n      container: isHeadless ? null : document.getElementById('cy'),\n      headless: isHeadless,\n      styleEnabled: !isHeadless,\n      boxSelectionEnabled: false,\n      textureOnViewport: true,\n    \n      style: [\n        {\n          selector: 'node',\n          css: {\n            'content': 'data(id)',\n            'text-valign': 'center',\n            'text-halign': 'center'\n          }\n        },\n        {\n          selector: ':parent',\n          css: {\n            'text-valign': 'top',\n            'text-halign': 'center'      \n          },\n          style: {\n            'shape' : 'roundrectangle',\n          }\n        },\n        {\n          selector: 'edge',\n          css: {\n            'curve-style': 'bezier',\n            'target-arrow-shape': 'triangle'\n          }\n        },\n        {\n          'selector': 'node[label]',\n          'style': {\n            'label': 'data(label)',\n            'text-valign': 'bottom',\n            'text-halign': 'center'\n          }\n        },\n        {\n          selector: '.reigon',\n          css: {\n              'background-color': '#2f3138',\n              'color' : '#C0C0C0',\n              'font-size' : '5em',\n              \"text-valign\": \"top\"\n          },\n        },\n        {\n          selector: '.map-F',\n          css: {\n              'background-color': '#ffc0c3',\n              'color' : '#C0C0C0',\n              'font-size' : '2em'\n          }\n        },\n        {\n          selector: '.map-C',\n          css: {\n              'background-color': '#c0c3ff',\n              'color' : '#C0C0C0',\n              'font-size' : '2em'\n          }\n        },\n        {\n          selector: '.map-E',\n          css: {\n              'background-color': '#c3ffc0',\n              'color' : '#C0C0C0',\n              'font-size' : '2em'\n          }\n        },\n        {\n          selector: '.warp',\n          css: {\n            'line-color': '#f92411',\n            \"curve-style\": \"straight-triangle\",\n          }\n        },\n        {\n          selector: '.conditional',\n          css: {\n            'line-color': '#1911f9'\n          }\n        },\n        {\n          selector: '.fixed',\n          css: {\n            'opacity': '0.5'\n          }\n        }\n      ],\n    \n      elements: {\n        nodes: [],\n        edges: []\n      }\n    });\n\n\n    cy.add(new ReigonNode(\"KANTO\"));\n    cy.add(new ReigonNode(\"JOHTO\"));\n    cy.add(new ReigonNode(\"HOENN\"));\n\n    let data = [...mapData];\n\n    // Add the nodes\n    data.forEach(d => {\n\n      if (!cy.getElementById(toMapBank(d[0])).length) {\n          cy.add(new AreaNode(d)).addClass(\"map-\" + d[0][0]);\n      }\n\n      cy.add(new WarpNode(d));\n    })\n\n    // Add fixed edges\n    data.forEach(d => {\n\n      let connections = d[1].connections ? d[1].connections : {};\n\n      Object.entries(connections).forEach(entry => {\n\n        if (typeof entry[1] == 'string') {\n\n          // Conditional Connection\n          progressionState.remainingConditionalEdges.add(new CondidtionalEdge(d[0], entry[0], entry[1]));\n\n          // Temporarily add conditional edges in the graph so we can work out what areas will be connected in future\n          if (cy.getElementById(entry[0]).length > 0) {\n            cy.add(new CondidtionalEdge(d[0], entry[0], entry[1]))\n          }\n\n        } else {\n\n          // Fixed Connection       \n\n          // Only draw path if connection node is present in total list of warps\n          // i.e if I'm only doing warps to first gym, don't draw a connection to a gym 2 level warp \n          if (cy.getElementById(entry[0]).length > 0) {\n            cy.add(new FixedEdge(d[0], entry[0]))\n          }\n        }\n      });\n    });\n\n    // calculate future connected areas then remove all conditional edges from the network\n    progressionState.unconnectedComponents = cy.elements().components()\n                                                          .filter(e => e.size() > 1)\n                                                          .map(e => e.toArray().filter(n => n.group() == \"nodes\" && n.data().isWarp && n.data().hasMultipleConnections).map(p => p.data().id))\n                                                          .filter(arr => arr.length > 0);\n    progressionState.remainingConditionalEdges.forEach(node => cy.getElementById(node.data.id).remove());\n\n    cy.nodes().forEach(function(node){\n      node.css(\"width\", 80);\n      node.css(\"height\", 80);\n    });\n\n    if (!isHeadless) {\n        cy.layout({name: 'cose-bilkent', animationDuration: 1000, nodeDimensionsIncludeLabels: true}).run();\n    }\n\n    progressionState.makeFinalLocationsKey();\n    return progressionState;\n}\n\n/* HINTS */\nfunction getHint(location) {\n  let mapData = new Map(Object.entries(getMapData()));\n  let warp = warpList.get(mapData.get(location).to);\n  if (!warp) {\n    return \"NOT PRESENT\";\n  }\n  let info = mapData.get(warp.toRomCode + \",\" + warp.toBank + \",\" + warp.toMap + \",\" + warp.toWarpNo).name;\n  let hint = warp.toRomCode == \"E\" ? \"HOENN - \" : (warp.toRomCode == \"C\" ? \"JOHTO - \" : \"KANTO - \");\n  return hint + info.split(\"-\")[0].trim() + \" - \" + info.split(\"-\")[1].trim();\n}\n\nvar HINTABLE_LOCATIONS = {\n  \"BROCK\"               : \"FR,6,2,1\"  ,\n  \"MISTY\"               : \"FR,7,5,1\"  ,\n  \"LT SURGE\"            : \"FR,9,6,1\"  ,\n  \"ERIKA\"               : \"FR,10,16,1\",\n  \"KOGA\"                : \"FR,11,3,1\" ,\n  \"SABRINA\"             : \"FR,14,3,1\" ,\n  \"BLAINE\"              : \"FR,12,0,1\" ,\n  \"GIOVANNI\"            : \"FR,5,1,1\"  ,\n  \"E4 LORELEI\"          : \"FR,1,75,0\" ,\n  \"E4 BRUNO (FR)\"       : \"FR,1,76,0\" ,\n  \"E4 AGATHA\"           : \"FR,1,77,0\" ,\n  \"E4 LANCE\"            : \"FR,1,78,0\" ,\n  \"CHAMPION RIVAL\"      : \"FR,1,79,0\" ,\n\n  \"FALKNER\"            : \"C,8,1,0\" ,\n  \"BUGSY\"              : \"C,3,3,0\" ,\n  \"WHITNEY\"            : \"C,11,3,0\",\n  \"MORTY\"              : \"C,12,1,0\",\n  \"CHUCK\"              : \"C,4,1,0\" ,\n  \"JASMINE\"            : \"C,10,0,0\",\n  \"PRYCE\"              : \"C,14,0,0\",\n  \"CLAIR\"              : \"C,15,0,0\",\n  \"E4 WILL\"            : \"C,16,0,0\",\n  \"E4 KOGA\"            : \"C,16,1,0\",\n  \"E4 BRUNO (C)\"       : \"C,16,2,0\",\n  \"E4 KAREN\"           : \"C,16,3,0\",\n  \"CHAMPION LANCE\"     : \"C,16,4,0\", \n\n  \"ROXANNE\"          : \"E,11,3,0\"  ,\n  \"BRAWLY\"           : \"E,3,3,0\"   ,\n  \"WATTSON\"          : \"E,10,0,0\"  ,\n  \"FLANNERY\"         : \"E,4,1,0\"   ,\n  \"NORMAN\"           : \"E,8,1,0\"   ,\n  \"WINONA\"           : \"E,12,1,0\"  ,\n  \"TATE AND LIZA\"    : \"E,14,0,0\"  ,\n  \"JUAN\"             : \"E,15,0,0\"  , \n  \"E4 SIDNEY\"        : \"E,16,0,0\"  ,\n  \"E4 PHOEBE\"        : \"E,16,1,0\"  ,\n  \"E4 GLACIA\"        : \"E,16,2,0\"  ,\n  \"E4 DRAKE\"         : \"E,16,3,0\"  ,\n  \"CHAMPION WALLACE\" : \"E,16,4,0\"  ,\n  \"STEVEN\"           : \"E,24,107,0\",\n}\n"],"names":["mixedGameData","Object","entries","FIRE_RED_WARPS","forEach","e","CRYSTAL_WARPS","EMERALD_WARPS","remappingsData","isHeadless","warpList","Map","getMapData","getRandomisationAlgorithm","generateRandomMappings","getRandomisationConfig","config","kantoLevel","document","getElementById","value","johtoLevel","hoennLevel","getFlagData","FLAG_DATA","mappingToWarps","mappingData","mappedList","mapping","from","trigger","toParts","target","split","set","PKWarp","source","async","mapWarps","seed","flagsState","unaddedConditionalEdges","mapData","getFilteredData","flagData","apply","getAugmetedRemappingData","updateHashDisplay","storageManager","persist","WarpListData","rng","RNG","getHash","progressionState","initMappingGraph","ProgressionState","root","getInitialWarp","unconnectedComponents","filter","a","includes","moreWarpsToMap","doNextMapping","updateProgressionState","cy","add","WarpNode","window","WarpEdge","getBaseRemappingData","KEY_LOCATION_DATA","filterIgnored","k","ignore","filterByConfig","usabledWarps","w","filterLevel","get","level","filteGroupedNotMain","groupMain","grouped","toMapBank","s","arr","this","remainingConditionalEdges","Set","flags","unmarkedLocations","LOCATIONS_TRIGGER","unmarkedFlags","COMPOSITE_FLAGS","unmarkedKeyLocations","KEY_LOCATIONS","Array","exportMapping","find","then","data","JSON","stringify","file","File","type","saveAs","importMapping","files","reader","FileReader","readAsText","onload","readerEvent","content","result","warpListData","parse","updateWarpListData","jhotoLevel","M","FormSelect","getInstance","_handleSelectChangeBound","innerHTML","Math","abs","toString","toUpperCase","romCode","bank","map","warpNo","toRomCode","toBank","toMap","toWarpNo","input","hash","len","length","i","charCodeAt","m","c","state","floor","random","ReigonNode","id","classes","AreaNode","node","parent","toReigon","label","name","trim","isWarp","isMapped","hasMultipleConnections","connections","values","n","FixedEdge","CondidtionalEdge","condition","count","remappingData","addTriggerData","addGroupedMappings","groupMappings","groups","g","push","to","edges","warpIdData","findAccessibleUnmappedNodes","cy1","nodeSet","elements","bfs","roots","directed","visit","v","u","depth","accessibleNodes","cachedNodes","inacessibleNodes","nodes","not","inaccesibleFlagLocations","has","inaccesibleKeyLocations","size","warp1","nextRange","delete","warp2","shouldCacheNodes","inacessibleHubs","degree","randomComponent","randomNodeIdFromComponent","console","log","currentNodes","location","every","flag","conditionalEdges","cytoscape","container","headless","styleEnabled","boxSelectionEnabled","textureOnViewport","style","selector","css","shape","color","opacity","d","addClass","entry","components","toArray","group","p","remove","layout","animationDuration","nodeDimensionsIncludeLabels","run","makeFinalLocationsKey","getHint","warp","info","prototype","finalLocations","HINTABLE_LOCATIONS","l","nextInt","nextFloat","start","end","rangeSize","randomUnder1","choice","array","BROCK","MISTY","ERIKA","KOGA","SABRINA","BLAINE","GIOVANNI","FALKNER","BUGSY","WHITNEY","MORTY","CHUCK","JASMINE","PRYCE","CLAIR","ROXANNE","BRAWLY","WATTSON","FLANNERY","NORMAN","WINONA","JUAN","STEVEN"],"version":3,"file":"index.31aa1b3d.js.map"}