{"mappings":"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","sources":["dist/user_scripts/AudioGlueCode.js"],"sourcesContent":["\"use strict\";\n/*\n Copyright (C) 2012-2015 Grant Galitz\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nfunction GlueCodeMixer(playButton) {\n    var parentObj = this;\n    this.audio = new XAudioServer(2, this.sampleRate, 0, this.bufferAmount, null, function () {\n        parentObj.checkHeartbeats();\n    }, function () {\n        parentObj.checkPostHeartbeats();\n    }, 1, function () {\n        //Disable audio in the callback here:\n        parentObj.disableAudio();\n    }, playButton);\n    this.outputUnits = [];\n    this.outputUnitsValid = [];\n    this.initializeBuffer();\n}\nGlueCodeMixer.prototype.sampleRate = 44100;\nGlueCodeMixer.prototype.bufferAmount = 44100;\nGlueCodeMixer.prototype.channelCount = 2;\nGlueCodeMixer.prototype.initializeBuffer = function () {\n    this.buffer = new AudioSimpleBuffer(this.channelCount,\n                                         this.bufferAmount);\n}\nGlueCodeMixer.prototype.appendInput = function (inUnit) {\n    if (this.audio) {\n        for (var index = 0; index < this.outputUnits.length; index++) {\n            if (!this.outputUnits[index]) {\n                break;\n            }\n        }\n        this.outputUnits[index] = inUnit;\n        this.outputUnitsValid.push(inUnit);\n        inUnit.registerStackPosition(index);\n    }\n    else if (typeof inUnit.errorCallback == \"function\") {\n        inUnit.errorCallback();\n    }\n}\nGlueCodeMixer.prototype.unregister = function (stackPosition) {\n    this.outputUnits[stackPosition] = null;\n    this.outputUnitsValid = [];\n    for (var index = 0, length = this.outputUnits.length; index < length; ++index) {\n        if (this.outputUnits[index]) {\n            this.outputUnitsValid.push(this.outputUnits);\n        }\n    }\n}\nGlueCodeMixer.prototype.checkHeartbeats = function () {\n    var inputCount = this.outputUnitsValid.length;\n    for (var inputIndex = 0, output = 0; inputIndex < inputCount; ++inputIndex) {\n        this.outputUnitsValid[inputIndex].heartBeatCallback();\n    }\n}\nGlueCodeMixer.prototype.checkPostHeartbeats = function () {\n    var inputCount = this.outputUnitsValid.length;\n    for (var inputIndex = 0, output = 0; inputIndex < inputCount; ++inputIndex) {\n        this.outputUnitsValid[inputIndex].postHeartBeatCallback();\n    }\n}\nGlueCodeMixer.prototype.checkAudio = function () {\n    if (this.audio) {\n        var inputCount = this.outputUnitsValid.length;\n        for (var inputIndex = 0, output = 0; inputIndex < inputCount; ++inputIndex) {\n            this.outputUnitsValid[inputIndex].prepareShift();\n        }\n        for (var count = 0, requested = this.findLowestBufferCount(); count < requested; ++count) {\n            for (var inputIndex = 0, output = 0; inputIndex < inputCount; ++inputIndex) {\n                output += this.outputUnitsValid[inputIndex].shift();\n            }\n            this.buffer.push(output);\n        }\n        var bufferLength = this.buffer.count();\n        this.audio.writeAudioNoCallback(this.buffer.buffer, bufferLength);\n        this.buffer.reset();\n    }\n}\nGlueCodeMixer.prototype.findLowestBufferCount = function () {\n    var count = 0;\n    for (var inputIndex = 0, inputCount = this.outputUnitsValid.length; inputIndex < inputCount; ++inputIndex) {\n        var tempCount = this.outputUnitsValid[inputIndex].buffer.resampledSamplesLeft();\n        if (tempCount > 0) {\n            if (count > 0) {\n                count = Math.min(count, tempCount);\n            }\n            else {\n                count = tempCount;\n            }\n        }\n    }\n    return Math.min(count, this.channelCount * this.bufferAmount);\n}\nGlueCodeMixer.prototype.disableAudio = function () {\n    this.audio = null;\n}\nfunction GlueCodeMixerInput(mixer) {\n    this.mixer = mixer;\n    this.volume = 1;\n}\nGlueCodeMixerInput.prototype.initialize = function (channelCount, sampleRate, bufferAmount, heartBeatCallback, postHeartBeatCallback, errorCallback) {\n    this.channelCount = channelCount;\n    this.sampleRate = sampleRate;\n    this.bufferAmount = bufferAmount;\n    this.heartBeatCallback = heartBeatCallback;\n    this.postHeartBeatCallback = postHeartBeatCallback;\n    this.errorCallback = errorCallback;\n    var oldBuffer = this.buffer;\n    this.buffer = new AudioBufferWrapper(this.channelCount,\n                                         this.mixer.channelCount,\n                                         this.bufferAmount,\n                                         this.sampleRate,\n                                         this.mixer.sampleRate);\n    if (oldBuffer) {\n        //If re-using same mixer input node, copy old buffer contents into the new buffer:\n        this.buffer.copyOld(oldBuffer);\n    }\n}\nGlueCodeMixerInput.prototype.register = function () {\n    this.mixer.appendInput(this);\n}\nGlueCodeMixerInput.prototype.setVolume = function (volume) {\n    this.volume = Math.min(Math.max(volume, 0), 1);\n}\nGlueCodeMixerInput.prototype.prepareShift = function () {\n    this.buffer.resampleRefill();\n}\nGlueCodeMixerInput.prototype.shift = function () {\n    return this.buffer.shift() * this.volume;\n}\nGlueCodeMixerInput.prototype.push = function (buffer, start, end) {\n    this.buffer.push(buffer, start, end);\n    this.mixer.checkAudio();\n}\nGlueCodeMixerInput.prototype.pushDeferred = function (buffer, start, end) {\n    this.buffer.push(buffer, start, end);\n}\nGlueCodeMixerInput.prototype.flush = function () {\n    this.mixer.checkAudio();\n}\nGlueCodeMixerInput.prototype.remainingBuffer = function () {\n    return this.buffer.remainingBuffer() + (Math.floor((this.mixer.audio.remainingBuffer() * this.sampleRate / this.mixer.sampleRate) / this.mixer.channelCount) * this.mixer.channelCount);\n}\nGlueCodeMixerInput.prototype.registerStackPosition = function (stackPosition) {\n    this.stackPosition = stackPosition;\n}\nGlueCodeMixerInput.prototype.unregister = function () {\n    this.mixer.unregister(this.stackPosition);\n}\nGlueCodeMixerInput.prototype.setBufferSpace = function (bufferAmount) {\n    this.buffer.setBufferSpace(bufferAmount);\n}\nfunction AudioBufferWrapper(channelCount,\n                            mixerChannelCount,\n                            bufferAmount,\n                            sampleRate,\n                            mixerSampleRate) {\n    this.channelCount = channelCount;\n    this.mixerChannelCount = mixerChannelCount;\n    this.bufferAmount = bufferAmount;\n    this.sampleRate = sampleRate;\n    this.mixerSampleRate = mixerSampleRate;\n    this.initialize();\n}\nAudioBufferWrapper.prototype.initialize = function () {\n    this.inBufferSize = this.bufferAmount * this.mixerChannelCount;\n    this.inBuffer = getFloat32Array(this.inBufferSize);\n    this.resampler = new Resampler(this.sampleRate, this.mixerSampleRate, this.mixerChannelCount, this.inBuffer);\n    this.outBufferSize = this.resampler.outputBuffer.length;\n    this.outBuffer = getFloat32Array(this.outBufferSize);\n    this.inputOffset = 0;\n    this.resampleBufferStart = 0;\n    this.resampleBufferEnd = 0;\n}\nAudioBufferWrapper.prototype.copyOld = function (oldBuffer) {\n    this.resampleRefill();\n    while (oldBuffer.resampleBufferStart != oldBuffer.resampleBufferEnd) {\n        this.outBuffer[this.resampleBufferEnd++] = oldBuffer.outBuffer[oldBuffer.resampleBufferStart++];\n        if (this.resampleBufferEnd == this.outBufferSize) {\n            this.resampleBufferEnd = 0;\n        }\n        if (this.resampleBufferStart == this.resampleBufferEnd) {\n            this.resampleBufferStart += this.mixerChannelCount;\n            if (this.resampleBufferStart == this.outBufferSize) {\n                this.resampleBufferStart = 0;\n            }\n        }\n        if (oldBuffer.resampleBufferStart == oldBuffer.outBufferSize) {\n            oldBuffer.resampleBufferStart = 0;\n        }\n    }\n}\nAudioBufferWrapper.prototype.push = function (buffer, start, end) {\n    var length  = Math.min(buffer.length, end);\n    if (this.channelCount < this.mixerChannelCount) {\n        for (; start < length && this.inputOffset < this.inBufferSize;) {\n            for (var index = this.channelCount; index < this.mixerChannelCount; ++index) {\n                this.inBuffer[this.inputOffset++] = buffer[start];\n            }\n            for (index = 0; index < this.channelCount && start < length; ++index) {\n                this.inBuffer[this.inputOffset++] = buffer[start++];\n            }\n        }\n    }\n    else if (this.channelCount == this.mixerChannelCount) {\n        for (; start < length && this.inputOffset < this.inBufferSize;) {\n            this.inBuffer[this.inputOffset++] = buffer[start++];\n        }\n    }\n    else {\n        for (; start < length && this.inputOffset < this.inBufferSize;) {\n            for (index = 0; index < this.mixerChannelCount && start < length; ++index) {\n                this.inBuffer[this.inputOffset++] = buffer[start++];\n            }\n            start += this.channelCount - this.mixerChannelCount;\n        }\n    }\n}\nAudioBufferWrapper.prototype.shift = function () {\n    var output = 0;\n    if (this.resampleBufferStart != this.resampleBufferEnd) {\n        output = this.outBuffer[this.resampleBufferStart++];\n        if (this.resampleBufferStart == this.outBufferSize) {\n            this.resampleBufferStart = 0;\n        }\n    }\n    return output;\n}\nAudioBufferWrapper.prototype.resampleRefill = function () {\n    if (this.inputOffset > 0) {\n        //Resample a chunk of audio:\n        var resampleLength = this.resampler.resampler(this.inputOffset);\n        var resampledResult = this.resampler.outputBuffer;\n        for (var index2 = 0; index2 < resampleLength;) {\n            this.outBuffer[this.resampleBufferEnd++] = resampledResult[index2++];\n            if (this.resampleBufferEnd == this.outBufferSize) {\n                this.resampleBufferEnd = 0;\n            }\n            if (this.resampleBufferStart == this.resampleBufferEnd) {\n                this.resampleBufferStart += this.mixerChannelCount;\n                if (this.resampleBufferStart == this.outBufferSize) {\n                    this.resampleBufferStart = 0;\n                }\n            }\n        }\n        this.inputOffset = 0;\n    }\n}\nAudioBufferWrapper.prototype.setBufferSpace = function (bufferAmount) {\n    while (this.inputOffset < bufferAmount && this.inputOffset < this.inBufferSize) {\n        this.inBuffer[this.inputOffset++] = 0;\n    }\n}\nAudioBufferWrapper.prototype.remainingBuffer = function () {\n    return (Math.floor((this.resampledSamplesLeft() * this.resampler.ratioWeight) / this.mixerChannelCount) * this.mixerChannelCount) + this.inputOffset;\n}\nAudioBufferWrapper.prototype.resampledSamplesLeft = function () {\n    return ((this.resampleBufferStart <= this.resampleBufferEnd) ? 0 : this.outBufferSize) + this.resampleBufferEnd - this.resampleBufferStart;\n}\nfunction AudioSimpleBuffer(channelCount, bufferAmount) {\n    this.channelCount = channelCount;\n    this.bufferAmount = bufferAmount;\n    this.outBufferSize = this.channelCount * this.bufferAmount;\n    this.stackLength = 0;\n    this.buffer = getFloat32Array(this.outBufferSize);\n}\nAudioSimpleBuffer.prototype.push = function (data) {\n    if (this.stackLength < this.outBufferSize) {\n        this.buffer[this.stackLength++] = data;\n    }\n}\nAudioSimpleBuffer.prototype.count = function () {\n    return this.stackLength;\n}\nAudioSimpleBuffer.prototype.reset = function () {\n    this.stackLength = 0;\n}\n"],"names":["GlueCodeMixer","playButton","parentObj","this","audio","XAudioServer","sampleRate","bufferAmount","checkHeartbeats","checkPostHeartbeats","disableAudio","outputUnits","outputUnitsValid","initializeBuffer","GlueCodeMixerInput","mixer","volume","AudioBufferWrapper","channelCount","mixerChannelCount","mixerSampleRate","initialize","AudioSimpleBuffer","outBufferSize","stackLength","buffer","getFloat32Array","prototype","appendInput","inUnit","index","length","push","registerStackPosition","errorCallback","unregister","stackPosition","inputCount","inputIndex","heartBeatCallback","postHeartBeatCallback","checkAudio","output","prepareShift","count","requested","findLowestBufferCount","shift","bufferLength","writeAudioNoCallback","reset","tempCount","resampledSamplesLeft","Math","min","oldBuffer","copyOld","register","setVolume","max","resampleRefill","start","end","pushDeferred","flush","remainingBuffer","floor","setBufferSpace","inBufferSize","inBuffer","resampler","Resampler","outputBuffer","outBuffer","inputOffset","resampleBufferStart","resampleBufferEnd","resampleLength","resampledResult","index2","ratioWeight","data"],"version":3,"file":"index.d953e635.js.map"}