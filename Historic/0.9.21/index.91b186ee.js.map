{"mappings":"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","sources":["dist/user_scripts/XAudioJS/resampler.js"],"sourcesContent":["\"use strict\";\n//JavaScript Audio Resampler\n//Copyright (C) 2011-2015 Grant Galitz\n//Released to Public Domain\nfunction Resampler(fromSampleRate, toSampleRate, channels, inputBuffer) {\n    //Input Sample Rate:\n    this.fromSampleRate = +fromSampleRate;\n    //Output Sample Rate:\n    this.toSampleRate = +toSampleRate;\n    //Number of channels:\n    this.channels = channels | 0;\n    //Type checking the input buffer:\n    if (typeof inputBuffer != \"object\") {\n        throw(new Error(\"inputBuffer is not an object.\"));\n    }\n    if (!(inputBuffer instanceof Array) && !(inputBuffer instanceof Float32Array) && !(inputBuffer instanceof Float64Array)) {\n        throw(new Error(\"inputBuffer is not an array or a float32 or a float64 array.\"));\n    }\n    this.inputBuffer = inputBuffer;\n    //Initialize the resampler:\n    this.initialize();\n}\nResampler.prototype.initialize = function () {\n\t//Perform some checks:\n\tif (this.fromSampleRate > 0 && this.toSampleRate > 0 && this.channels > 0) {\n\t\tif (this.fromSampleRate == this.toSampleRate) {\n\t\t\t//Setup a resampler bypass:\n\t\t\tthis.resampler = this.bypassResampler;\t\t//Resampler just returns what was passed through.\n            this.ratioWeight = 1;\n            this.outputBuffer = this.inputBuffer;\n\t\t}\n\t\telse {\n            this.ratioWeight = this.fromSampleRate / this.toSampleRate;\n\t\t\tif (this.fromSampleRate < this.toSampleRate) {\n\t\t\t\t/*\n\t\t\t\t\tUse generic linear interpolation if upsampling,\n\t\t\t\t\tas linear interpolation produces a gradient that we want\n\t\t\t\t\tand works fine with two input sample points per output in this case.\n\t\t\t\t*/\n\t\t\t\tthis.compileLinearInterpolationFunction();\n\t\t\t\tthis.lastWeight = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t\tCustom resampler I wrote that doesn't skip samples\n\t\t\t\t\tlike standard linear interpolation in high downsampling.\n\t\t\t\t\tThis is more accurate than linear interpolation on downsampling.\n\t\t\t\t*/\n\t\t\t\tthis.compileMultiTapFunction();\n\t\t\t\tthis.tailExists = false;\n\t\t\t\tthis.lastWeight = 0;\n\t\t\t}\n\t\t\tthis.initializeBuffers();\n\t\t}\n\t}\n\telse {\n\t\tthrow(new Error(\"Invalid settings specified for the resampler.\"));\n\t}\n}\nResampler.prototype.compileLinearInterpolationFunction = function () {\n\tvar toCompile = \"var outputOffset = 0;\\\n    if (bufferLength > 0) {\\\n        var buffer = this.inputBuffer;\\\n        var weight = this.lastWeight;\\\n        var firstWeight = 0;\\\n        var secondWeight = 0;\\\n        var sourceOffset = 0;\\\n        var outputOffset = 0;\\\n        var outputBuffer = this.outputBuffer;\\\n        for (; weight < 1; weight += \" + this.ratioWeight + \") {\\\n            secondWeight = weight % 1;\\\n            firstWeight = 1 - secondWeight;\";\n            for (var channel = 0; channel < this.channels; ++channel) {\n                toCompile += \"outputBuffer[outputOffset++] = (this.lastOutput[\" + channel + \"] * firstWeight) + (buffer[\" + channel + \"] * secondWeight);\";\n            }\n        toCompile += \"}\\\n        weight -= 1;\\\n        for (bufferLength -= \" + this.channels + \", sourceOffset = Math.floor(weight) * \" + this.channels + \"; sourceOffset < bufferLength;) {\\\n            secondWeight = weight % 1;\\\n            firstWeight = 1 - secondWeight;\";\n            for (var channel = 0; channel < this.channels; ++channel) {\n                toCompile += \"outputBuffer[outputOffset++] = (buffer[sourceOffset\" + ((channel > 0) ? (\" + \" + channel) : \"\") + \"] * firstWeight) + (buffer[sourceOffset + \" + (this.channels + channel) + \"] * secondWeight);\";\n            }\n            toCompile += \"weight += \" + this.ratioWeight + \";\\\n            sourceOffset = Math.floor(weight) * \" + this.channels + \";\\\n        }\";\n        for (var channel = 0; channel < this.channels; ++channel) {\n            toCompile += \"this.lastOutput[\" + channel + \"] = buffer[sourceOffset++];\";\n        }\n        toCompile += \"this.lastWeight = weight % 1;\\\n    }\\\n    return outputOffset;\";\n\tthis.resampler = Function(\"bufferLength\", toCompile);\n}\nResampler.prototype.compileMultiTapFunction = function () {\n\tvar toCompile = \"var outputOffset = 0;\\\n    if (bufferLength > 0) {\\\n        var buffer = this.inputBuffer;\\\n        var weight = 0;\";\n        for (var channel = 0; channel < this.channels; ++channel) {\n            toCompile += \"var output\" + channel + \" = 0;\"\n        }\n        toCompile += \"var actualPosition = 0;\\\n        var amountToNext = 0;\\\n        var alreadyProcessedTail = !this.tailExists;\\\n        this.tailExists = false;\\\n        var outputBuffer = this.outputBuffer;\\\n        var currentPosition = 0;\\\n        do {\\\n            if (alreadyProcessedTail) {\\\n                weight = \" + this.ratioWeight + \";\";\n                for (channel = 0; channel < this.channels; ++channel) {\n                    toCompile += \"output\" + channel + \" = 0;\"\n                }\n            toCompile += \"}\\\n            else {\\\n                weight = this.lastWeight;\";\n                for (channel = 0; channel < this.channels; ++channel) {\n                    toCompile += \"output\" + channel + \" = this.lastOutput[\" + channel + \"];\"\n                }\n                toCompile += \"alreadyProcessedTail = true;\\\n            }\\\n            while (weight > 0 && actualPosition < bufferLength) {\\\n                amountToNext = 1 + actualPosition - currentPosition;\\\n                if (weight >= amountToNext) {\";\n                    for (channel = 0; channel < this.channels; ++channel) {\n                        toCompile += \"output\" + channel + \" += buffer[actualPosition++] * amountToNext;\"\n                    }\n                    toCompile += \"currentPosition = actualPosition;\\\n                    weight -= amountToNext;\\\n                }\\\n                else {\";\n                    for (channel = 0; channel < this.channels; ++channel) {\n                        toCompile += \"output\" + channel + \" += buffer[actualPosition\" + ((channel > 0) ? (\" + \" + channel) : \"\") + \"] * weight;\"\n                    }\n                    toCompile += \"currentPosition += weight;\\\n                    weight = 0;\\\n                    break;\\\n                }\\\n            }\\\n            if (weight <= 0) {\";\n                for (channel = 0; channel < this.channels; ++channel) {\n                    toCompile += \"outputBuffer[outputOffset++] = output\" + channel + \" / \" + this.ratioWeight + \";\"\n                }\n            toCompile += \"}\\\n            else {\\\n                this.lastWeight = weight;\";\n                for (channel = 0; channel < this.channels; ++channel) {\n                    toCompile += \"this.lastOutput[\" + channel + \"] = output\" + channel + \";\"\n                }\n                toCompile += \"this.tailExists = true;\\\n                break;\\\n            }\\\n        } while (actualPosition < bufferLength);\\\n    }\\\n    return outputOffset;\";\n\tthis.resampler = Function(\"bufferLength\", toCompile);\n}\nResampler.prototype.bypassResampler = function (upTo) {\n    return upTo;\n}\nResampler.prototype.initializeBuffers = function () {\n\t//Initialize the internal buffer:\n    var outputBufferSize = (Math.ceil(this.inputBuffer.length * this.toSampleRate / this.fromSampleRate / this.channels * 1.000000476837158203125) * this.channels) + this.channels;\n\ttry {\n\t\tthis.outputBuffer = new Float32Array(outputBufferSize);\n\t\tthis.lastOutput = new Float32Array(this.channels);\n\t}\n\tcatch (error) {\n\t\tthis.outputBuffer = [];\n\t\tthis.lastOutput = [];\n\t}\n}"],"names":["Resampler","fromSampleRate","toSampleRate","channels","inputBuffer","this","Error","Array","Float32Array","Float64Array","initialize","prototype","resampler","bypassResampler","ratioWeight","outputBuffer","compileLinearInterpolationFunction","lastWeight","compileMultiTapFunction","tailExists","initializeBuffers","toCompile","channel","Function","upTo","outputBufferSize","Math","ceil","length","lastOutput","error"],"version":3,"file":"index.91b186ee.js.map"}